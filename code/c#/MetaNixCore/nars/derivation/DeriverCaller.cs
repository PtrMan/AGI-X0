using System;
using System.Collections.Generic;
using System.Linq;

using MetaNix.nars.autogenerated;

using TemporaryDerivedCompoundWithDecoration = MetaNix.nars.derivation.TemporaryDerivedCompoundType<MetaNix.nars.derivation.TemporaryDerivedCompoundDecoration>;
using TemporaryDerivedCompound = MetaNix.nars.derivation.TemporaryDerivedCompoundType<int>;
using MetaNix.nars.config;

namespace MetaNix.nars.derivation {
    public class DeriverCaller {
        // - calls deriver
        // - checks if the termcomplexity is too large, if so its thrown away
        // - for each remaining derivation result insert and translate to compounds and termTuples
        public static IEnumerable<TemporaryDerivedTerm> deriverCaller(
            CompoundAndTermContext compoundAndTermContext,
            Compound premiseLeft,
            Compound premiseRight,
            out IList<TemporaryDerivedCompoundWithDecorationAndTruth> derivedCompoundTermsWithDecorationAndTruth,
            bool insert = true
        ) {

            /* still in here because it shows how to recalculate complexity recursivly
            uint recalcTermComplexityRecursive(TemporaryDerivedCompound* derivedCompound) {
                uint getTermComplexityOfLeaf() {
                    assert( derivedCompound.isLeaf );
                    return reasonerInstance.getTermComplexityOfAndByTermReferer(derivedCompound.termReferer);
                }

                if( derivedCompound.isLeaf ) {
                    return derivedCompound.termComplexity = getTermComplexityOfLeaf();
                }
                else if( derivedCompound )
                else {
                    derivedCompound.termComplexity = getComplexityOfFlagsOfCopula(derivedCompound.flagsOfCopula);

                    // TODO< implement for nonbinary >
                    assert(derivedCompound.leftChildren !is null);
                    assert(derivedCompound.rightChildren !is null);
                    derivedCompound.termComplexity += recalcTermComplexityRecursive(derivedCompound.leftChildren);
                    derivedCompound.termComplexity += recalcTermComplexityRecursive(derivedCompound.rightChildren);

                    return derivedCompound.termComplexity;
                }
            }
            */

            bool isQuestion = false; // HACK, TODO< pull this from the task >

            IList<TemporaryDerivedTerm> temporaryDerivedTerms = Autogenerated.derive(compoundAndTermContext, premiseLeft, premiseRight, isQuestion);
            foreach (TemporaryDerivedTerm iterationTemporaryDerivedTerms in temporaryDerivedTerms ) {
                // TODO< optimize this by storing the termcomplexity into the TemporaryDerivedTerm in the method ! >
                iterationTemporaryDerivedTerms.derivedCompound.termComplexity = iterationTemporaryDerivedTerms.derivedCompound.calcComplexityRecursive(compoundAndTermContext);

                // recalcTermComplexityRecursive(iterationTemporaryDerivedTerms.derivedCompound);
            }

            // filter by maximal term complexity
            var filteredTerms = temporaryDerivedTerms.Where(a => a.derivedCompound.termComplexity <= Parameters.MAXIMAL_TERM_COMPLEXITY);

            // debug
            // for now we just dump the TemporaryDerivedCompounds and the compounds they reference
            debugTermsToConsole(compoundAndTermContext, filteredTerms.ToArray());

            derivedCompoundTermsWithDecorationAndTruth = null;
            if (insert) {
                // insert and translate to compounds and termTuples
                derivedCompoundTermsWithDecorationAndTruth = insertDerivedCompoundTermsAndReturnDerivedCompoundTermsWithDecoration(compoundAndTermContext, filteredTerms.ToArray());
            }

            return filteredTerms;
        }

        static IList<TemporaryDerivedCompoundWithDecorationAndTruth> insertDerivedCompoundTermsAndReturnDerivedCompoundTermsWithDecoration(CompoundAndTermContext compoundAndTermContext, IList<TemporaryDerivedTerm> derivedCompoundTerms) {
            List<TemporaryDerivedCompoundWithDecorationAndTruth> derivedCompoundTermsWithDecorationAndTruth = new List<TemporaryDerivedCompoundWithDecorationAndTruth>();

            foreach (TemporaryDerivedTerm iterationDerivedCompoundTerm in derivedCompoundTerms ) {
                var newDerivedCompoundTermWithDecorationAndTruth = new TemporaryDerivedCompoundWithDecorationAndTruth();
                newDerivedCompoundTermWithDecorationAndTruth.derivedCompoundWithDecoration = TemporaryDerivedCompoundDecoration.makeRecursive(iterationDerivedCompoundTerm.derivedCompound);
                newDerivedCompoundTermWithDecorationAndTruth.truthfunction = iterationDerivedCompoundTerm.truthfunction;
                derivedCompoundTermsWithDecorationAndTruth.Add(newDerivedCompoundTermWithDecorationAndTruth);
            }

            foreach (var iterationDerivedCompoundTermWithDecorationAndTruth in derivedCompoundTermsWithDecorationAndTruth ) {
                insertDerivedCompoundTerm(compoundAndTermContext, iterationDerivedCompoundTermWithDecorationAndTruth.derivedCompoundWithDecoration);
            }

            return derivedCompoundTermsWithDecorationAndTruth;
        }

        static void insertDerivedCompoundTerm(CompoundAndTermContext compoundAndTermContext, TemporaryDerivedCompoundWithDecoration derivedCompoundTerm) {
            // TODO< good place to hook in (compound)term compression >


            // the index of the compound in the compound table is returned with the decoration of the argument "derivedCompoundTerm"
            void innerFnInsertIfItDoesntExistRecursivly(TemporaryDerivedCompoundWithDecoration derivedCompoundTermInner)
            {
                // recurse to children
                if (derivedCompoundTermInner.type == TemporaryDerivedCompoundWithDecoration.EnumType.COMPOUND) {
                    innerFnInsertIfItDoesntExistRecursivly(derivedCompoundTermInner.leftChildren);
                    innerFnInsertIfItDoesntExistRecursivly(derivedCompoundTermInner.rightChildren);
                }

                // create if not exist

                if (derivedCompoundTermInner.type == TemporaryDerivedCompoundWithDecoration.EnumType.COMPOUND) { // is a Temporary compound(term)
                    bool innerFnEarlyTestExistsCompound()
                    {
                        var childrenCompoundsWithDecorations = new TemporaryDerivedCompoundWithDecoration[] { derivedCompoundTermInner.leftChildren, derivedCompoundTermInner.rightChildren };
                        return compoundAndTermContext.existTermTuple(new List<TermOrCompoundTermOrVariableReferer>(childrenCompoundsWithDecorations.Select(n => n.decoration.returnReferer(compoundAndTermContext))));
                    }

                    // returns compoundIndex
                    CompoundIndex innerFnCreateCompoundAndAddToReasoner(TermTupleIndex termTupleIndex) {
                        // create compound
                        ulong compoundIndex2 = compoundAndTermContext.getCompoundCreateIndex(); // get the index where the compound will be created
                        
                        Compound.MakeParameters compoundMakeParameters2 = new Compound.MakeParameters();
                        compoundMakeParameters2.termComplexity = derivedCompoundTermInner.termComplexity;
                        compoundMakeParameters2.flagsOfCopula = derivedCompoundTermInner.flagsOfCopula;
                        compoundMakeParameters2.thisTermReferer = TermOrCompoundTermOrVariableReferer.makeNonatomic(/* 32 bit conversion*/(int)compoundIndex2); // create new referer based on the compound index
                        compoundMakeParameters2.termTupleIndex = termTupleIndex;

                        Compound createdCompound = compoundAndTermContext.createCompound(compoundMakeParameters2);

                        // insert compound
                        compoundAndTermContext.addCompound(createdCompound);

                        return CompoundIndex.make(/*quick and dirty conversation*/(uint)compoundIndex2);
                    }



			        // build the term, calculate the hash, try to lookup the compound based on the hash
			        // if it exists we return the compoundIndex of the found compound
			        // if it doesn't exist we create a new Compound and return it

			        if(innerFnEarlyTestExistsCompound() ) { // if the term tuple exists then the compound could exist
                        
                        // build compound and calc hash and try to look it up and compare it to the built compound

                        var childrenCompoundsWithDecorations = new TemporaryDerivedCompoundWithDecoration[] { derivedCompoundTermInner.leftChildren, derivedCompoundTermInner.rightChildren };
                        TermTupleIndex termTupleIndex = compoundAndTermContext.getTermTupleIndexByReferers(childrenCompoundsWithDecorations.Select(n => n.decoration.returnReferer(compoundAndTermContext)).ToArray<TermOrCompoundTermOrVariableReferer>());

				        //   * build compound
				        Compound.MakeParameters compoundMakeParameters = new Compound.MakeParameters();
                        compoundMakeParameters.termComplexity = derivedCompoundTermInner.termComplexity;
				        compoundMakeParameters.flagsOfCopula = derivedCompoundTermInner.flagsOfCopula;

				        //compoundMakeParameters.compoundId;      we don't need to initialize it because the hash computation for this lookup doesn't use it
				        //                                        the hash computation doesn't use it because we don't know it

				        //compoundMakeParameters.thisTermReferer  we don't need to intialize it because it's not used for hash computation
				        compoundMakeParameters.termTupleIndex = termTupleIndex;
				        Compound createdCompoundForHash = Compound.make(compoundMakeParameters);
                        //   * calc hash
                        createdCompoundForHash.updateHash(/*with compoundId*/false);

				        //    * lookup hash and compare if possible
				        //      if the compound doesn't exist we create and add it
				        CompoundIndex compoundIndex2;
				        if(compoundAndTermContext.existsCompoundWithoutCompoundId(createdCompoundForHash, out compoundIndex2) ) {
					        // set as the result the compound
					        derivedCompoundTermInner.decoration.compoundIndex = compoundIndex2;
				        }
				        else {
					        // create and add compound
					        compoundIndex2 = innerFnCreateCompoundAndAddToReasoner(termTupleIndex);

                            // set as the result the compound
                            derivedCompoundTermInner.decoration.compoundIndex = compoundIndex2;
				        }
			        }
			        else { // if the term tuple doesn't exist then the compound can't exist so we have to create and return it

                        // create termTuple
                        var childrenCompoundsWithDecorations = new TemporaryDerivedCompoundWithDecoration[] { derivedCompoundTermInner.leftChildren, derivedCompoundTermInner.rightChildren };
                        TermTupleIndex termTupleIndex = compoundAndTermContext.addTermTupleByReferers(childrenCompoundsWithDecorations.Select(n => n.decoration.returnReferer(compoundAndTermContext)).ToArray());
				        // create and add compound
				        CompoundIndex compoundIndex = innerFnCreateCompoundAndAddToReasoner(termTupleIndex);

                        // set as the result the compound
                        derivedCompoundTermInner.decoration.compoundIndex = compoundIndex;
			        }
		        }
		        else if(
                    derivedCompoundTermInner.type == TemporaryDerivedCompoundType<TemporaryDerivedCompoundDecoration>.EnumType.LEAF ||
			        derivedCompoundTermInner.type == TemporaryDerivedCompoundType<TemporaryDerivedCompoundDecoration>.EnumType.INDEPENDENTVARIABLE ||
			        derivedCompoundTermInner.type == TemporaryDerivedCompoundType<TemporaryDerivedCompoundDecoration>.EnumType.DEPENDENTVARIABLE
		        ) {

                    
                    if ( derivedCompoundTermInner.type == TemporaryDerivedCompoundType<TemporaryDerivedCompoundDecoration>.EnumType.LEAF ) {

                        TermOrCompoundTermOrVariableReferer termReferer = derivedCompoundTermInner.termReferer;
                        
                        derivedCompoundTermInner.decoration.referer = termReferer;
                    }
                    /* commented because we have to figure out how to translate the variable id's 

			        else if( derivedCompoundTermInner.type == TemporaryDerivedCompoundType<TemporaryDerivedCompoundDecoration>.EnumType.INDEPENDENTVARIABLE ) {
				        compoundId = derivedCompoundTermInner.independentVariableId; // ASSUMPTION< compoundId is the id of the variable >
			        }
			        else if( derivedCompoundTermInner.type == TemporaryDerivedCompoundType<TemporaryDerivedCompoundDecoration>.EnumType.DEPENDENTVARIABLE ) {
				        compoundId = derivedCompoundTermInner.dependentVariableId; // ASSUMPTION< compoundId is the id of the variable >
			        }
			        */
                    else {
                        throw new Exception("Internal error");
                    }

                    
                    
		        }
		        else {
			        throw new Exception("Internal error");
		        }
	        }
            // for now we just check for the existence and insert it recursivly
            innerFnInsertIfItDoesntExistRecursivly(derivedCompoundTerm);
        }

        // debugging
        // ===
    
        static private void debugTermsToConsole(CompoundAndTermContext compoundAndTermContext, TemporaryDerivedTerm[] terms) {
            string message = "";
            foreach (var iterationTerm in terms ) {
                message += String.Format("derived term = ({0})\n", dumpToString(iterationTerm, compoundAndTermContext));
            }

            Console.WriteLine(message);
        }

        private static string dumpToString(TemporaryDerivedTerm derivedTerm, CompoundAndTermContext compoundAndTermContext) {
            return String.Format("{0} truthfn={1}", derivedTerm.derivedCompound.debugToStringRecursivly(compoundAndTermContext), derivedTerm.truthfunction.ToString());
        }

    }
}